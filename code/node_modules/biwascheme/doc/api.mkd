
Basic types
===========

String
------

### `format`

BiwaScheme provides [SRFI-28](http://srfi.schemers.org/srfi-28/srfi-28.html) simple `format`.

#### Basic usage

    (define name "yhara")
    (define msg (format "Hello, ~a!" name))  ;=> "Hello, yhara!"

* ~a : Embed item using `display`
* ~s : Embed item using `write`
* ~% : Newline (\n)
* ~~ : Tilde (~)

#### Format and print

When `#t` is specified as first argument, `format` outputs string to current port. 

    (format #t "Ans: ~a" 42)

Numeric types
=============

### Add, Sub, Mul, Div

  (+ 1 2)  ;=> gt
  (- 1 2)
  (* 1 2)
  (/ 1 2)

### Div and Mod


Control structure
=================

Loop
----

### do

    (do ((ls '(a b c) (cdr ls))
         (i  1        (+ i 1)))
        ((null? ls) "ok")
      (print i (car ls)))         ;=> Prints 1a, 2b, 3c and returns "ok"

### named let

    (let loop ((a 1)
               (b 10))
      (if (= a b)
        "ok"
        (loop (+ a 1) (- b 1))))

### dotimes

    (dotimes (i 10)
      (print i))        ;=> Prints 0, 1, ..., 9

Specify result value

    (dotimes (i 10 "ok")
      (print i))        ;=> Prints 0, 1, ..., 9
    ;=> Returns "ok"

Values
------

Unlike JavaScript, Scheme function can return multiple values.

### Return two values

    (define (x-and-y)
      (values 1 2))

### Receiving values

Use syntax `receive`:

    (receive (a b) (x-and-y)
      (print a b))

`receive` is implemented with `call-with-values`.

    (call-with-values (lambda () (x-and-y))
                      (lambda (a b) (print a b)))

`let-values`

    (let-values ((x y) (x-and-y)
                 (a b) (a-and-y))
      (print x y a b))

There is also `let*-values`.

Advanced types
==============

Record
------

Record type is defined in R6RS Library.

* [Records (R6RS Library Chapter 6)](http://www.r6rs.org/final/html/r6rs-lib/r6rs-lib-Z-H-7.html#node_chap_6)

### Define record type

You can define record type with syntax `define-record-type`.

    ; Defines `make-point`, `point?`, `point-x`, `point-y`
    (define-record-type point (fields x y))

    (define p1 (make-point 1 2))

    (print (point? p1))   ;=> #t
    (print (point-x p1))  ;=> 1
    (print (point-y p1))  ;=> 2

Note that each instance of record type is first class value in Scheme, while 
record type itself is not.

### Mutable fields

    ; Defines `point-x-set!`, `point-y-set!`
    (define-record-type point
      (fields (mutable x) (mutable y)))

    (define p1 (make-point 1 2))
    (point-x-set! p1 7)

    (print (point-x p1)) ;=> 7

### Inheritance

    ; Define parent type
    (define-record-type box (fields wid hei))
    
    ; Define child type
    (define-record-type colbox (parent box) (fields color))

    (define mybox (make-colbox 4 5 "red"))
    (print (box-wid mybox))       ;=> 4
    (print (box-hei mybox))       ;=> 5
    (print (colbox-color mybox))  ;=> red

### Customize constructor

Specify `protocol` to customize constructor behavior

    (define-record-type rect (field wid hei)
      (protocol
        (lambda (p)
          (lambda (wid hei)
            (when (or (<= 0 wid) (<= 0 hei))
              (raise "wid and hei must be > 0"))
            (p wid hei)))))

Alternatively, you can change constructor name and define it by yourself.
(In this case, you should be careful not to use `make-rect-orig` directly)

    (define-record-type (rect make-rect-orig rect?) (field wid hei)

    (define (make-rect wid hei)
      (when (or (<= 0 wid) (<= 0 hei))
        (raise "wid and hei must be > 0"))
      (make-rect-orig wid hei)))))

Customize constructor of child type:

    ; Parent type
    (define-record-type rect (fields wid hei))
    
    ; Child type
    (define-record-type colored-square (parent rect) (fields color)
      (protocol 
        (lambda (n)
          (lambda (size color)  ; You can customize arity of constructor
            (when (<= 0 size))
              (raise "size must be > 0"))
            ((n size size) color))))

    (define mysquare (make-colored-square 4 "red"))

Of course, you can define protocol as seaprate function.

    (define (colored-square-protocol n)
      (lambda (size color)    ; Protocol must return a function.
        (when (<= 0 size))
          (raise "size must be > 0"))
        ((n size size) color))))

    (define-record-type colored-square (parent rect) (fields color)
      (protocol colored-square-protocol))

### Advanced features

See the R6RS spec for advanced features such as `sealed`, `opaque`,
`nongenerative` or internal procedural layer.

* [Records (R6RS Library Chapter 6)](http://www.r6rs.org/final/html/r6rs-lib/r6rs-lib-Z-H-7.html#node_chap_6)

Hashtable
---------

Hashtable is defined in R6RS Library.

* [Hashtables (R6RS Library Chapter 13)](http://www.r6rs.org/final/html/r6rs-lib/r6rs-lib-Z-H-14.html#node_chap_13)

### Basic usage

    ; Create a hashtable with strings as keys
    (define h (make-hashtable string-hash string=?))

    ; Write
    (hashtable-set! h "apple" 10)

    ; Read
    (print (hashtable-ref h "apple"))  ;=> 10
    (print (hashtable-keys h))         ;=> #("apple")   Returns vector.

    ; Check
    (print (hashtable-contains? h "apple"))  ;=> #t

    ; Delete
    (hashtable-delete! h "apple")

### Hash keys

    ; String keys
    (define h (make-hashtable string-hash string=?))        ; case sensitive
    (define h (make-hashtable string-ci-hash string-ci=?))  ; case insensitive
 
    ; Numeric keys (compare keys by `eq?`)
    (define h (make-eq-hashtable))

    ; Symbol keys
    (define h (make-hashtable symbol-hash symbol=?))
    (define h (make-eq-hashtable))  ; this works too

    ; List keys (compare keys by `equal?`)
    (define h (make-hashtable equal-hash equal?))
    (hashtable-set! h '(35.345639 136.170901) "Lake Biwa")

    ; Compare keys by eqv?
    (define h (make-eqv-hashtable))

Note: you should not mutate hash keys (like by string-upcase! or set-car!)

Enumeration
-----------

Enumeration is defined in R6RS Library.

* [Enumerations (R6RS Library Chapter 14)](http://www.r6rs.org/final/html/r6rs-lib/r6rs-lib-Z-H-15.html#node_chap_14)

### Basic usage

    ; Defines syntax `suit` and `suit-set`
    (define-enumeration suit (spade heart club diamond) suit-set)
    
    ; `suit` returns a symbol
    (define first-card (cons (suit heart) 12))
    (print (car first-card))    ;=> heart
    (symbol? (car first-card))  ;=> true
    
    ; `suit` raises error when argument is invalid.
    (define second-card (list 12 (suit haart)))  ;=> Error

### Enum set

    ; Define enumeration
    (define-enumeration suit (spade heart club diamond) suit-set)
    
    ; Make a enum set
    (define black-suits (suit-set spade club))
    
    ; Check
    (print (enum-set-member? 'spade black-suits)) ;=> #t

Note: Enum set is a separate type from list. 
You can use enum-set->list to get a list of symbols. 

    (equal? '(spade club) (enum-set->list black-suits))  ;=> #t

Also note that enum set is is first class value in Scheme, while 
enumeration type itself is not.

### Tips: How to use `apply` to make an enum-set

Since `suit-set` is syntax, `(apply suit-set ls))` is invalid.
You can use `enum-set-constructor` to acquire constructor as function.

    ; Define enumeration
    (define-enumeration suit (spade heart club diamond) suit-set)
    ; Define constructor function
    (define make-suit-set (enum-set-constructor (suit-set)))
    
    (define ls '(spade club))
    (define black-suits (apply make-suit-set ls))  ; Works

Date
----

Date API is defined in [SRFI-19](http://srfi.schemers.org/srfi-19/srfi-19.html)
and implemented with JavaScript Date class.

### Basic usage

    (define t (current-date))

    (print (date-nanosecond t))
    (print (date-millisecond t))
    (print (date-second t))
    (print (date-minute t))
    (print (date-hour t))
    (print (date-day t))
    (print (date-month t))
    (print (date-year t))
    (print (date-week-day t))

### Parsing date

`string->date` of SRFI-19 is not implemented yet.
BiwaScheme has parse-date instead, which uses Date.parse of JavaScript.

    (define t (parse-date "2012/01/01"))

### Format date

    (define t (parse-date "2012/01/02 03:04:05"))
    
    (print (date->string t "~a")) ;=> Mon
    (print (date->string t "~A")) ;=> Monday
    (print (date->string t "~b")) ;=> Jan
    (print (date->string t "~B")) ;=> January
    (print (date->string t "~c")) ;=> Mon Jan 02 2012 03:04:05 GMT+0900 (JST)
    (print (date->string t "~d")) ;=> 02
    
    ...

Regexp
------

Regular expression API is derived [from Gauche](http://practical-scheme.net/gauche/man/gauche-refe_51.html).

### regexp-exec

    ; Returns trueish value when matched
    > (regexp-exec "\\d+" "Today is 06 Oct.")
    ("06")
    
    ; Returns #f if not matched
    > (regexp-exec "\\d+" "Today is october sixth.")
    #f
    
    ; Returns matched substring and 
    > (regexp-exec "(\\d+) (\\w+)" "Today is 06 Oct.")
    ("06 Oct" "06" "Oct")

Note: BiwaScheme does not have Regexp literal yet,
so you need to write `\` twice to use `\d`, `\w`, etc.

### regexp-replace-all

    > (regexp-replace-all "(\\d+)" "Today is 06 Oct." "<b>$1</b>")
    "Today is <b>06</b> Oct."

